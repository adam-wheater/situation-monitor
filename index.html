<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Situation Monitor</title>
    <link rel="stylesheet" href="index.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <script src="https://unpkg.com/globe.gl"></script>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <h1 class="title">Situation Monitor</h1>
            <span class="status" id="status">Ready</span>
        </div>
        <div class="header-right">
            <button class="refresh-btn monitors-btn" onclick="openMonitorForm()">+ Monitor</button>
            <button class="settings-btn" onclick="toggleSettings()">Panels</button>
            <button class="refresh-btn" id="refreshBtn" onclick="refreshAll()">Refresh</button>
        </div>
    </header>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal" onclick="if(event.target === this) toggleSettings()">
        <div class="settings-content">
            <div class="settings-title">Panel Settings</div>
            <div class="settings-section">
                <div class="settings-section-title">Toggle Panels</div>
                <div id="panelToggles"></div>
            </div>
            <div class="settings-section">
                <div class="settings-section-title">Layout</div>
                <div class="settings-hint" style="margin-bottom: 0.5rem;">Drag panel headers to reorder</div>
                <button class="settings-reset" onclick="resetPanelOrder()">Reset Layout</button>
            </div>
            <div class="settings-section monitors-section">
                <div class="settings-section-title">Custom Monitors</div>
                <div class="settings-hint" style="margin-bottom: 0.5rem;">Track keywords with optional map locations</div>
                <div class="monitors-list" id="monitorsList"></div>
                <button class="add-monitor-btn" onclick="openMonitorForm()">+ Add Monitor</button>
            </div>
            <button class="settings-close" onclick="toggleSettings()">Close</button>
        </div>
    </div>

    <!-- Monitor Form Modal -->
    <div class="monitor-form-overlay" id="monitorFormOverlay" onclick="if(event.target === this) closeMonitorForm()">
        <div class="monitor-form">
            <div class="monitor-form-title" id="monitorFormTitle">Add Monitor</div>
            <input type="hidden" id="monitorEditId">
            <div class="monitor-form-field">
                <label class="monitor-form-label">Name</label>
                <input type="text" class="monitor-form-input" id="monitorName" placeholder="e.g., TSMC Supply Chain">
            </div>
            <div class="monitor-form-field">
                <label class="monitor-form-label">Keywords</label>
                <input type="text" class="monitor-form-input" id="monitorKeywords" placeholder="e.g., tsmc, taiwan semiconductor, chip">
                <div class="monitor-form-hint">Comma-separated. Matches headlines containing any keyword.</div>
            </div>
            <div class="monitor-form-field">
                <label class="monitor-form-label">Color</label>
                <div class="monitor-form-colors" id="monitorColors"></div>
            </div>
            <div class="monitor-form-field">
                <label class="monitor-form-label">Map Location (Optional)</label>
                <div class="monitor-form-location">
                    <input type="text" class="monitor-form-input" id="monitorLat" placeholder="Latitude">
                    <input type="text" class="monitor-form-input" id="monitorLon" placeholder="Longitude">
                </div>
                <div class="monitor-form-hint">Leave blank for keyword-only monitoring. Add coords to show on map.</div>
            </div>
            <div class="monitor-form-actions">
                <button class="monitor-cancel-btn" onclick="closeMonitorForm()">Cancel</button>
                <button class="monitor-save-btn" onclick="saveMonitor()">Save</button>
            </div>
        </div>
    </div>

    <main class="dashboard">
        <!-- Global Intelligence Map -->
        <section class="panel" data-panel="map" style="grid-column: span 4;">
            <div class="panel-header">
                <span class="panel-title">Global Activity Monitor</span>
                <span class="panel-count" id="mapLegend" style="font-size: 9px;">
                    <span style="color: #00ff88;">‚óè Low</span>
                    <span style="color: #ffcc00; margin-left: 0.4rem;">‚óè Elevated</span>
                    <span style="color: #ff4444; margin-left: 0.4rem;">‚óè High</span>
                    <span style="color: #ff6600; margin-left: 0.4rem;">‚ñ≤ Wx</span>
                    <span style="color: #ff8800; margin-left: 0.4rem;">‚óâ Quake</span>
                    <span style="color: #00aaff; margin-left: 0.4rem;">‚öì Naval</span>
                    <span style="color: #aa44ff; margin-left: 0.4rem;">‚óé Cable</span>
                    <span style="color: #ffff00; margin-left: 0.4rem;">‚ò¢ Nuke</span>
                    <span style="color: #ff00ff; margin-left: 0.4rem;">‚òÖ Base</span>
                </span>
            </div>
            <div class="panel-content" id="mapPanel" style="max-height: none; height: 550px; overflow: hidden; background: #0a1a14; position: relative;">
                <svg id="mapSvg" style="width:100%;height:100%;"></svg>
                <div id="mapTooltip" style="position:absolute;display:none;background:rgba(0,20,15,0.95);border:1px solid #00ff88;padding:10px 14px;border-radius:4px;font-size:11px;color:#00ff88;pointer-events:none;z-index:1000;max-width:280px;font-family:monospace;line-height:1.4;"></div>
            </div>
            <script>
                // Inline map render with hotspots
                (async function() {
                    const svg = d3.select('#mapSvg');
                    const tooltip = document.getElementById('mapTooltip');
                    const mapPanel = document.getElementById('mapPanel');
                    const width = 800, height = 500;
                    svg.attr('viewBox', `0 0 ${width} ${height}`);

                    const projection = d3.geoEquirectangular()
                        .scale(130)
                        .center([0, 20])
                        .translate([width/2, height/2]);

                    const path = d3.geoPath().projection(projection);

                    // Everything drawn onto this layer so pan/zoom works.
                    const g = svg.append('g').attr('class', 'map-root');

                    // Proxy-aware fetch helpers (uses same-origin /proxy when available)
                    const __proxyState = { checked: false, available: false };
                    async function __probeLocalProxy() {
                        if (__proxyState.checked) return __proxyState.available;
                        __proxyState.checked = true;
                        try {
                            const controller = new AbortController();
                            const t = setTimeout(() => controller.abort(), 800);
                            const resp = await fetch('/proxy/ping', { cache: 'no-store', signal: controller.signal });
                            clearTimeout(t);
                            if (!resp.ok) return false;
                            const text = await resp.text();
                            __proxyState.available = String(text || '').trim().toLowerCase().startsWith('ok');
                            return __proxyState.available;
                        } catch {
                            return false;
                        }
                    }

                    async function __fetchJson(url) {
                        const useProxy = await __probeLocalProxy();
                        const finalUrl = useProxy ? `/proxy?url=${encodeURIComponent(url)}` : url;
                        const resp = await fetch(finalUrl, { cache: 'no-store' });
                        if (!resp.ok) throw new Error(`Fetch failed (${resp.status})`);
                        return await resp.json();
                    }

                    function escapeHtml(str) {
                        return String(str)
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#039;');
                    }

                    // Data cache for tooltips
                    const dataCache = {};

                    // Get local time at longitude
                    function getLocalTime(lon) {
                        const now = new Date();
                        const utcHours = now.getUTCHours();
                        const utcMinutes = now.getUTCMinutes();
                        const offsetHours = Math.round(lon / 15);
                        let localHours = (utcHours + offsetHours + 24) % 24;
                        const ampm = localHours >= 12 ? 'PM' : 'AM';
                        localHours = localHours % 12 || 12;
                        return `${localHours}:${utcMinutes.toString().padStart(2, '0')} ${ampm}`;
                    }

                    // Fetch weather from Open-Meteo
                    async function getWeather(lat, lon) {
                        const key = `weather_${lat}_${lon}`;
                        if (dataCache[key]) return dataCache[key];
                        try {
                            const data = await __fetchJson(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code,wind_speed_10m,wind_gusts_10m,precipitation`);
                            const temp = data.current?.temperature_2m;
                            const tempF = temp ? Math.round(temp * 9/5 + 32) : null;
                            const wind = data.current?.wind_speed_10m;
                            const gust = data.current?.wind_gusts_10m;
                            const precip = data.current?.precipitation;
                            const code = data.current?.weather_code;
                            const conditions = {
                                0: '‚òÄÔ∏è Clear', 1: 'üå§Ô∏è Mostly clear', 2: '‚õÖ Partly cloudy', 3: '‚òÅÔ∏è Overcast',
                                45: 'üå´Ô∏è Fog', 48: 'üå´Ô∏è Fog', 51: 'üåßÔ∏è Drizzle', 53: 'üåßÔ∏è Drizzle', 55: 'üåßÔ∏è Drizzle',
                                61: 'üåßÔ∏è Rain', 63: 'üåßÔ∏è Rain', 65: 'üåßÔ∏è Heavy rain', 71: 'üå®Ô∏è Snow', 73: 'üå®Ô∏è Snow',
                                75: 'üå®Ô∏è Heavy snow', 77: 'üå®Ô∏è Snow', 80: 'üåßÔ∏è Showers', 81: 'üåßÔ∏è Showers', 82: '‚õàÔ∏è Heavy showers',
                                85: 'üå®Ô∏è Snow', 86: 'üå®Ô∏è Snow', 95: '‚õàÔ∏è Thunderstorm', 96: '‚õàÔ∏è Thunderstorm', 99: '‚õàÔ∏è Thunderstorm'
                            };

                            // Simple local heuristic warning label (global; no keys required).
                            let warning = null;
                            const windMph = wind ? Math.round(wind) : null;
                            const gustMph = gust ? Math.round(gust) : null;
                            const precipMm = (typeof precip === 'number') ? precip : null;

                            if ([95, 96, 99].includes(code)) warning = '‚ö† Thunderstorm';
                            else if (gustMph !== null && gustMph >= 45) warning = '‚ö† Damaging winds';
                            else if (windMph !== null && windMph >= 30) warning = '‚ö† High winds';
                            else if (code === 65 || code === 82) warning = '‚ö† Heavy precip';
                            else if (precipMm !== null && precipMm >= 10) warning = '‚ö† Heavy precip';

                            const result = {
                                temp: tempF,
                                wind: windMph,
                                gust: gustMph,
                                condition: conditions[code] || '‚Äî',
                                warning
                            };
                            dataCache[key] = result;
                            return result;
                        } catch (e) { return null; }
                    }

                    // Fetch news from GDELT
                    async function getNews(query, lat, lon) {
                        const key = `news_${query}`;
                        if (dataCache[key]) return dataCache[key];
                        try {
                            const searchTerm = encodeURIComponent(query);
                            const data = await __fetchJson(`https://api.gdeltproject.org/api/v2/doc/doc?query=${searchTerm}&mode=artlist&maxrecords=3&format=json`);
                            const articles = data.articles?.slice(0, 2).map(a => a.title?.substring(0, 60) + '...') || [];
                            dataCache[key] = articles;
                            return articles;
                        } catch (e) { return []; }
                    }

                    // Fetch flight count from OpenSky
                    async function getFlightCount(lat, lon) {
                        const key = `flights_${Math.round(lat)}_${Math.round(lon)}`;
                        if (dataCache[key] !== undefined) return dataCache[key];
                        try {
                            const bbox = `${lon-3},${lat-3},${lon+3},${lat+3}`;
                            const data = await __fetchJson(`https://opensky-network.org/api/states/all?lamin=${lat-2}&lomin=${lon-2}&lamax=${lat+2}&lomax=${lon+2}`);
                            const count = data.states?.length || 0;
                            dataCache[key] = count;
                            return count;
                        } catch (e) { dataCache[key] = null; return null; }
                    }

                    // Build enhanced tooltip content
                    async function buildTooltip(name, lat, lon, baseContent, color) {
                        const localTime = getLocalTime(lon);
                        let html = `<strong style="color:${color}">${baseContent}</strong>`;
                        html += `<br><span style="opacity:0.7">üïê Local: ${localTime}</span>`;

                        // Show loading, then fetch data
                        tooltip.innerHTML = html + '<br><span style="opacity:0.5">Loading data...</span>';

                        const [weather, flights, news] = await Promise.all([
                            getWeather(lat, lon),
                            getFlightCount(lat, lon),
                            getNews(name, lat, lon)
                        ]);

                        if (weather) {
                            const windText = weather.wind !== null ? `${weather.wind}mph` : '‚Äî';
                            const gustText = weather.gust !== null ? ` (gust ${weather.gust}mph)` : '';
                            html += `<br><span style="opacity:0.7">${weather.condition} ${weather.temp}¬∞F, wind ${windText}${gustText}</span>`;
                            if (weather.warning) {
                                html += `<br><span style="color:#ff6600;font-size:10px">${weather.warning}</span>`;
                            }
                        }
                        if (flights !== null) {
                            html += `<br><span style="opacity:0.7">‚úàÔ∏è ${flights} aircraft nearby</span>`;
                        }
                        if (news && news.length > 0) {
                            html += `<br><span style="color:#888;font-size:9px">üì∞ ${news[0]}</span>`;
                        }

                        return html;
                    }

                    // Threat level colors
                    const threatColors = {
                        high: '#ff4444',
                        elevated: '#ffcc00',
                        low: '#00ff88'
                    };

                    // Hotspots data with descriptions and threat levels
                    const hotspots = [
                        { name: 'DC', lat: 38.9, lon: -77.0, level: 'low', desc: 'Washington DC ‚Äî US political center, White House, Pentagon, Capitol' },
                        { name: 'Moscow', lat: 55.75, lon: 37.6, level: 'elevated', desc: 'Moscow ‚Äî Kremlin, Russian military command, sanctions hub' },
                        { name: 'Beijing', lat: 39.9, lon: 116.4, level: 'elevated', desc: 'Beijing ‚Äî CCP headquarters, US-China tensions, tech rivalry' },
                        { name: 'Kyiv', lat: 50.45, lon: 30.5, level: 'high', desc: 'Kyiv ‚Äî Active conflict zone, Russian invasion ongoing' },
                        { name: 'Taipei', lat: 25.03, lon: 121.5, level: 'elevated', desc: 'Taipei ‚Äî Taiwan Strait tensions, TSMC, China threat' },
                        { name: 'Tehran', lat: 35.7, lon: 51.4, level: 'high', desc: 'Tehran ‚Äî Iran nuclear program, proxy conflicts, regional escalation' },
                        { name: 'Tel Aviv', lat: 32.07, lon: 34.78, level: 'high', desc: 'Tel Aviv ‚Äî Israel-Gaza conflict, active military operations' },
                        { name: 'London', lat: 51.5, lon: -0.12, level: 'low', desc: 'London ‚Äî Financial center, Five Eyes, NATO ally' },
                        { name: 'Brussels', lat: 50.85, lon: 4.35, level: 'low', desc: 'Brussels ‚Äî EU/NATO headquarters, European policy' },
                        { name: 'Pyongyang', lat: 39.03, lon: 125.75, level: 'elevated', desc: 'Pyongyang ‚Äî North Korea nuclear threat, missile tests' },
                        { name: 'Riyadh', lat: 24.7, lon: 46.7, level: 'elevated', desc: 'Riyadh ‚Äî Saudi oil, OPEC+, Yemen conflict, regional power' },
                        { name: 'Delhi', lat: 28.6, lon: 77.2, level: 'low', desc: 'Delhi ‚Äî India rising power, China border tensions' },
                        { name: 'Singapore', lat: 1.35, lon: 103.82, level: 'low', desc: 'Singapore ‚Äî Shipping chokepoint, Asian finance hub' },
                        { name: 'Tokyo', lat: 35.68, lon: 139.76, level: 'low', desc: 'Tokyo ‚Äî US ally, regional security, economic power' },
                        { name: 'Caracas', lat: 10.5, lon: -66.9, level: 'high', desc: 'Caracas ‚Äî Venezuela crisis, Maduro regime, US sanctions, humanitarian emergency' },
                        { name: 'Nuuk', lat: 64.18, lon: -51.72, level: 'elevated', desc: 'Nuuk ‚Äî Greenland, US acquisition interest, Arctic strategy, Denmark tensions' }
                    ];

                    try {
                        const world = await __fetchJson('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                        const countries = topojson.feature(world, world.objects.countries);

                        // Sanctioned countries (ISO numeric codes)
                        const sanctionedIds = [364, 408, 760, 862, 112, 643, 728, 729]; // Iran, NK, Syria, Venezuela, Belarus, Russia, South Sudan, Sudan

                        // Draw countries with sanctions highlighting
                        g.selectAll('path.country')
                            .data(countries.features)
                            .enter()
                            .append('path')
                            .attr('class', 'country')
                            .attr('d', path)
                            .attr('fill', d => sanctionedIds.includes(+d.id) ? '#2a1a1a' : '#0f3028')
                            .attr('stroke', d => sanctionedIds.includes(+d.id) ? '#4a2020' : '#1a5040')
                            .attr('stroke-width', 0.5);

                        // Draw graticule (grid lines)
                        const graticule = d3.geoGraticule().step([30, 30]);
                        g.append('path')
                            .datum(graticule)
                            .attr('d', path)
                            .attr('fill', 'none')
                            .attr('stroke', '#1a3830')
                            .attr('stroke-width', 0.3)
                            .attr('stroke-dasharray', '2,2');

                        // Ocean labels
                        const oceans = [
                            { name: 'ATLANTIC', lat: 25, lon: -40 },
                            { name: 'PACIFIC', lat: 0, lon: -150 },
                            { name: 'INDIAN', lat: -20, lon: 75 },
                            { name: 'ARCTIC', lat: 75, lon: 0 },
                            { name: 'SOUTHERN', lat: -60, lon: 0 }
                        ];
                        oceans.forEach(o => {
                            const [x, y] = projection([o.lon, o.lat]);
                            if (x && y) {
                                g.append('text')
                                    .attr('x', x).attr('y', y)
                                    .attr('fill', '#1a4a40')
                                    .attr('font-size', '10px')
                                    .attr('font-family', 'monospace')
                                    .attr('text-anchor', 'middle')
                                    .attr('opacity', 0.6)
                                    .text(o.name);
                            }
                        });

                        // Day/night terminator
                        const now = new Date();
                        const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
                        const declination = -23.45 * Math.cos((360/365) * (dayOfYear + 10) * Math.PI/180);
                        const hourAngle = (now.getUTCHours() + now.getUTCMinutes()/60) * 15 - 180;

                        const terminatorPoints = [];
                        for (let lat = -90; lat <= 90; lat += 2) {
                            const cosLat = Math.cos(lat * Math.PI/180);
                            const tanDec = Math.tan(declination * Math.PI/180);
                            const tanLat = Math.tan(lat * Math.PI/180);
                            let lon = -hourAngle + Math.acos(-tanDec * tanLat) * 180/Math.PI;
                            if (isNaN(lon)) lon = (lat * declination > 0) ? -hourAngle + 180 : -hourAngle;
                            terminatorPoints.push([lon, lat]);
                        }
                        for (let lat = 90; lat >= -90; lat -= 2) {
                            const cosLat = Math.cos(lat * Math.PI/180);
                            const tanDec = Math.tan(declination * Math.PI/180);
                            const tanLat = Math.tan(lat * Math.PI/180);
                            let lon = -hourAngle - Math.acos(-tanDec * tanLat) * 180/Math.PI;
                            if (isNaN(lon)) lon = (lat * declination > 0) ? -hourAngle - 180 : -hourAngle;
                            terminatorPoints.push([lon, lat]);
                        }

                        g.append('path')
                            .datum({type: 'Polygon', coordinates: [terminatorPoints]})
                            .attr('d', path)
                            .attr('fill', 'rgba(0,0,0,0.3)')
                            .attr('stroke', 'none');

                        // Conflict zones (approximate bounding boxes)
                        const conflictZones = [
                            { name: 'Ukraine', coords: [[30,52],[40,52],[40,45],[30,45],[30,52]], color: '#ff4444' },
                            { name: 'Gaza', coords: [[34,32],[35,32],[35,31],[34,31],[34,32]], color: '#ff4444' },
                            { name: 'Taiwan Strait', coords: [[117,28],[122,28],[122,22],[117,22],[117,28]], color: '#ffaa00' },
                            { name: 'Yemen', coords: [[42,19],[54,19],[54,12],[42,12],[42,19]], color: '#ff6644' },
                            { name: 'Sudan', coords: [[22,23],[38,23],[38,8],[22,8],[22,23]], color: '#ff6644' },
                            { name: 'Myanmar', coords: [[92,28],[101,28],[101,10],[92,10],[92,28]], color: '#ff8844' }
                        ];
                        conflictZones.forEach(zone => {
                            g.append('path')
                                .datum({type: 'Polygon', coordinates: [zone.coords]})
                                .attr('d', path)
                                .attr('fill', zone.color)
                                .attr('fill-opacity', 0.15)
                                .attr('stroke', zone.color)
                                .attr('stroke-width', 0.5)
                                .attr('stroke-opacity', 0.4);
                        });

                        // Shipping chokepoints
                        const chokepoints = [
                            { name: 'Suez', lat: 30.0, lon: 32.5, desc: 'Suez Canal ‚Äî 12% of global trade, Europe-Asia route' },
                            { name: 'Panama', lat: 9.1, lon: -79.7, desc: 'Panama Canal ‚Äî Americas transit, Pacific-Atlantic link' },
                            { name: 'Hormuz', lat: 26.5, lon: 56.5, desc: 'Strait of Hormuz ‚Äî 21% of global oil, Persian Gulf exit' },
                            { name: 'Malacca', lat: 2.5, lon: 101.0, desc: 'Strait of Malacca ‚Äî 25% of global trade, China supply line' },
                            { name: 'Bab el-M', lat: 12.5, lon: 43.3, desc: 'Bab el-Mandeb ‚Äî Red Sea gateway, Houthi threat zone' },
                            { name: 'Gibraltar', lat: 36.0, lon: -5.5, desc: 'Strait of Gibraltar ‚Äî Mediterranean access' },
                            { name: 'Bosporus', lat: 41.1, lon: 29.0, desc: 'Bosporus Strait ‚Äî Black Sea access, Russia exports' }
                        ];
                        chokepoints.forEach(cp => {
                            const [x, y] = projection([cp.lon, cp.lat]);
                            if (x && y) {
                                g.append('text')
                                    .attr('x', x).attr('y', y + 3)
                                    .attr('fill', '#00aaff')
                                    .attr('font-size', '10')
                                    .attr('font-family', 'monospace')
                                    .attr('text-anchor', 'middle')
                                    .text('‚óÜ');
                                g.append('text')
                                    .attr('x', x + 8).attr('y', y + 3)
                                    .attr('fill', '#00aaff')
                                    .attr('font-size', '7')
                                    .attr('font-family', 'monospace')
                                    .text(cp.name);
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 10)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.innerHTML = `<strong style="color:#00aaff">‚¨• ${cp.desc}</strong>`;
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', () => tooltip.style.display = 'none');
                            }
                        });

                        // Undersea cable landing points (major hubs)
                        const cableLandings = [
                            { name: 'NYC', lat: 40.7, lon: -74.0, desc: 'New York ‚Äî Transatlantic hub, 10+ cables' },
                            { name: 'Cornwall', lat: 50.1, lon: -5.5, desc: 'Cornwall UK ‚Äî Europe-Americas gateway' },
                            { name: 'Marseille', lat: 43.3, lon: 5.4, desc: 'Marseille ‚Äî Mediterranean hub, SEA-ME-WE' },
                            { name: 'Mumbai', lat: 19.1, lon: 72.9, desc: 'Mumbai ‚Äî India gateway, 10+ cables' },
                            { name: 'Singapore', lat: 1.3, lon: 103.8, desc: 'Singapore ‚Äî Asia-Pacific nexus' },
                            { name: 'Hong Kong', lat: 22.3, lon: 114.2, desc: 'Hong Kong ‚Äî China connectivity hub' },
                            { name: 'Tokyo', lat: 35.5, lon: 139.8, desc: 'Tokyo ‚Äî Trans-Pacific terminus' },
                            { name: 'Sydney', lat: -33.9, lon: 151.2, desc: 'Sydney ‚Äî Australia/Pacific hub' },
                            { name: 'LA', lat: 33.7, lon: -118.2, desc: 'Los Angeles ‚Äî Pacific gateway' },
                            { name: 'Miami', lat: 25.8, lon: -80.2, desc: 'Miami ‚Äî Americas/Caribbean hub' }
                        ];
                        cableLandings.forEach(cl => {
                            const [x, y] = projection([cl.lon, cl.lat]);
                            if (x && y) {
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 3)
                                    .attr('fill', 'none')
                                    .attr('stroke', '#aa44ff')
                                    .attr('stroke-width', 1.5);
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 10)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.innerHTML = `<strong style="color:#aa44ff">‚óé ${cl.desc}</strong>`;
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', () => tooltip.style.display = 'none');
                            }
                        });

                        // Nuclear facilities (major sites)
                        const nuclearSites = [
                            { name: 'Natanz', lat: 33.7, lon: 51.7, desc: 'Natanz ‚Äî Iran uranium enrichment' },
                            { name: 'Yongbyon', lat: 39.8, lon: 125.8, desc: 'Yongbyon ‚Äî North Korea nuclear complex' },
                            { name: 'Dimona', lat: 31.0, lon: 35.1, desc: 'Dimona ‚Äî Israel nuclear facility' },
                            { name: 'Bushehr', lat: 28.8, lon: 50.9, desc: 'Bushehr ‚Äî Iran nuclear power plant' },
                            { name: 'Zaporizhzhia', lat: 47.5, lon: 34.6, desc: 'Zaporizhzhia ‚Äî Europe largest NPP, conflict zone' },
                            { name: 'Chernobyl', lat: 51.4, lon: 30.1, desc: 'Chernobyl ‚Äî Exclusion zone, occupied 2022' },
                            { name: 'Fukushima', lat: 37.4, lon: 141.0, desc: 'Fukushima ‚Äî Decommissioning site' },
                            { name: 'Palo Verde', lat: 33.4, lon: -112.9, desc: 'Palo Verde ‚Äî US nuclear generating station (AZ)' },
                            { name: 'Vogtle', lat: 33.1, lon: -81.8, desc: 'Vogtle ‚Äî US nuclear plant (GA)' },
                            { name: 'Diablo Canyon', lat: 35.2, lon: -120.9, desc: 'Diablo Canyon ‚Äî US nuclear plant (CA)' },
                            { name: 'Gravelines', lat: 51.0, lon: 2.1, desc: 'Gravelines ‚Äî France nuclear power plant' },
                            { name: 'Cattenom', lat: 49.4, lon: 6.2, desc: 'Cattenom ‚Äî France nuclear power plant' },
                            { name: 'Flamanville', lat: 49.5, lon: -1.9, desc: 'Flamanville ‚Äî France nuclear plant (EPR site)' },
                            { name: 'Hinkley Point', lat: 51.2, lon: -3.1, desc: 'Hinkley Point ‚Äî UK nuclear plant complex' },
                            { name: 'Sizewell', lat: 52.2, lon: 1.6, desc: 'Sizewell ‚Äî UK nuclear plant complex' },
                            { name: 'Olkiluoto', lat: 61.2, lon: 21.4, desc: 'Olkiluoto ‚Äî Finland nuclear plant' },
                            { name: 'Barakah', lat: 23.7, lon: 53.9, desc: 'Barakah ‚Äî UAE nuclear power plant' },
                            { name: 'Taishan', lat: 21.9, lon: 112.99, desc: 'Taishan ‚Äî China nuclear power plant' },
                            { name: 'Daya Bay', lat: 22.6, lon: 114.55, desc: 'Daya Bay ‚Äî China nuclear power plant' },
                            { name: 'Tianwan', lat: 34.7, lon: 119.45, desc: 'Tianwan ‚Äî China nuclear power plant' },
                            { name: 'Kudankulam', lat: 8.17, lon: 77.71, desc: 'Kudankulam ‚Äî India nuclear power plant' },
                            { name: 'Tarapur', lat: 19.82, lon: 72.65, desc: 'Tarapur ‚Äî India nuclear power plant' },
                            { name: 'Akkuyu', lat: 36.14, lon: 33.54, desc: 'Akkuyu ‚Äî Turkey nuclear plant site' }
                        ];
                        nuclearSites.forEach(ns => {
                            const [x, y] = projection([ns.lon, ns.lat]);
                            if (x && y) {
                                // Radiation symbol (simplified)
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 2)
                                    .attr('fill', '#ffff00');
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 5)
                                    .attr('fill', 'none')
                                    .attr('stroke', '#ffff00')
                                    .attr('stroke-width', 1)
                                    .attr('stroke-dasharray', '3,3');
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 10)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.innerHTML = `<strong style="color:#ffff00">‚ò¢ ${ns.desc}</strong>`;
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', () => tooltip.style.display = 'none');
                            }
                        });

                        // Major military bases
                        const militaryBases = [
                            { name: 'Ramstein', lat: 49.4, lon: 7.6, desc: 'Ramstein ‚Äî US Air Force, NATO hub Germany' },
                            { name: 'Diego Garcia', lat: -7.3, lon: 72.4, desc: 'Diego Garcia ‚Äî US/UK Indian Ocean base' },
                            { name: 'Okinawa', lat: 26.5, lon: 127.9, desc: 'Okinawa ‚Äî US Forces Japan, Pacific presence' },
                            { name: 'Guam', lat: 13.5, lon: 144.8, desc: 'Guam ‚Äî US Pacific Command, bomber base' },
                            { name: 'Djibouti', lat: 11.5, lon: 43.1, desc: 'Djibouti ‚Äî US/China/France bases, Horn of Africa' },
                            { name: 'Qatar', lat: 25.1, lon: 51.3, desc: 'Al Udeid ‚Äî US CENTCOM forward HQ' },
                            { name: 'Kaliningrad', lat: 54.7, lon: 20.5, desc: 'Kaliningrad ‚Äî Russian Baltic exclave, missiles' },
                            { name: 'Sevastopol', lat: 44.6, lon: 33.5, desc: 'Sevastopol ‚Äî Russian Black Sea Fleet' },
                            { name: 'Hainan', lat: 18.2, lon: 109.5, desc: 'Hainan ‚Äî Chinese submarine base, South China Sea' },
                            { name: 'Incirlik', lat: 37.0, lon: 35.4, desc: 'Incirlik ‚Äî Turkey air base (NATO)' },
                            { name: 'Al Dhafra', lat: 24.25, lon: 54.55, desc: 'Al Dhafra ‚Äî UAE air base (US/coalition)' },
                            { name: 'Bandar Abbas', lat: 27.18, lon: 56.26, desc: 'Bandar Abbas ‚Äî Iran naval hub (Hormuz)' },
                            { name: 'Visakhapatnam', lat: 17.7, lon: 83.3, desc: 'Visakhapatnam ‚Äî India Eastern Naval Command' },
                            { name: 'Port Blair', lat: 11.67, lon: 92.74, desc: 'Port Blair ‚Äî India Andaman & Nicobar Command' },
                            { name: 'Pine Gap', lat: -23.8, lon: 133.74, desc: 'Pine Gap ‚Äî Australia/US signals intelligence' },
                            { name: 'Croughton', lat: 51.99, lon: -1.19, desc: 'Croughton ‚Äî UK/US communications hub' },
                            { name: 'Khamis Mushait', lat: 18.3, lon: 42.8, desc: 'Khamis Mushait ‚Äî Saudi air base region' }
                        ];
                        militaryBases.forEach(mb => {
                            const [x, y] = projection([mb.lon, mb.lat]);
                            if (x && y) {
                                g.append('text')
                                    .attr('x', x).attr('y', y + 3)
                                    .attr('fill', '#ff00ff')
                                    .attr('font-size', '10')
                                    .attr('font-family', 'monospace')
                                    .attr('text-anchor', 'middle')
                                    .attr('opacity', 0.9)
                                    .text('‚òÖ');
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 10)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.innerHTML = `<strong style="color:#ff00ff">‚òÖ ${mb.desc}</strong>`;
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', () => tooltip.style.display = 'none');
                            }
                        });

                        // Add pulse animation style
                        const style = document.createElement('style');
                        style.textContent = `
                            @keyframes pulse {
                                0% { r: 3; opacity: 0.9; }
                                50% { r: 6; opacity: 0.4; }
                                100% { r: 3; opacity: 0.9; }
                            }
                            @keyframes weatherPulse {
                                0% { opacity: 0.9; }
                                50% { opacity: 0.5; }
                                100% { opacity: 0.9; }
                            }
                            .hotspot-pulse { animation: pulse 2s ease-in-out infinite; }
                            .hotspot-hit { cursor: pointer; }
                            .weather-alert { animation: weatherPulse 1.5s ease-in-out infinite; }
                        `;
                        document.head.appendChild(style);

                        // Draw hotspots
                        hotspots.forEach(h => {
                            const [x, y] = projection([h.lon, h.lat]);
                            const color = threatColors[h.level] || threatColors.low;
                            if (x && y) {
                                // Outer pulsing ring
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 6)
                                    .attr('fill', 'none').attr('stroke', color)
                                    .attr('stroke-width', 1.5).attr('opacity', 0.6)
                                    .attr('class', 'hotspot-pulse');
                                // Inner solid circle
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 3)
                                    .attr('fill', color).attr('opacity', 0.9);
                                // Label
                                g.append('text')
                                    .attr('x', x + 8).attr('y', y + 3)
                                    .attr('fill', color).attr('font-size', '8')
                                    .attr('font-family', 'monospace')
                                    .text(h.name);
                                // Invisible hit area for tooltip
                                g.append('circle')
                                    .attr('cx', x).attr('cy', y).attr('r', 12)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', async function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        const levelLabel = h.level.charAt(0).toUpperCase() + h.level.slice(1);
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                        const html = await buildTooltip(h.name, h.lat, h.lon, `[${levelLabel}] ${h.desc}`, color);
                                        tooltip.innerHTML = html;
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', function() {
                                        tooltip.style.display = 'none';
                                    });
                            }
                        });

                        // Fetch and render weather alerts (US - NWS API)
                        try {
                            const weatherData = await __fetchJson('https://api.weather.gov/alerts/active?status=actual&severity=Extreme,Severe,Moderate');

                            // Weather severity colors
                            const weatherColors = {
                                'Extreme': '#ff0000',
                                'Severe': '#ff6600',
                                'Moderate': '#ffaa00',
                                'Minor': '#ffcc00'
                            };

                            // US state centroids for positioning alerts
                            const stateCentroids = {
                                'AL': [32.7, -86.7], 'AK': [64.0, -153.0], 'AZ': [34.2, -111.6], 'AR': [34.8, -92.4],
                                'CA': [37.2, -119.4], 'CO': [39.0, -105.5], 'CT': [41.6, -72.7], 'DE': [39.0, -75.5],
                                'FL': [28.6, -82.4], 'GA': [32.6, -83.4], 'HI': [20.8, -156.3], 'ID': [44.4, -114.6],
                                'IL': [40.0, -89.2], 'IN': [39.9, -86.3], 'IA': [42.0, -93.5], 'KS': [38.5, -98.4],
                                'KY': [37.5, -85.3], 'LA': [31.0, -92.0], 'ME': [45.4, -69.2], 'MD': [39.0, -76.8],
                                'MA': [42.2, -71.5], 'MI': [44.3, -85.4], 'MN': [46.3, -94.3], 'MS': [32.7, -89.7],
                                'MO': [38.3, -92.4], 'MT': [47.0, -109.6], 'NE': [41.5, -99.8], 'NV': [39.3, -116.6],
                                'NH': [43.7, -71.6], 'NJ': [40.1, -74.7], 'NM': [34.4, -106.1], 'NY': [42.9, -75.5],
                                'NC': [35.5, -79.4], 'ND': [47.4, -100.3], 'OH': [40.4, -82.8], 'OK': [35.6, -97.5],
                                'OR': [43.9, -120.6], 'PA': [40.9, -77.8], 'RI': [41.7, -71.5], 'SC': [33.9, -80.9],
                                'SD': [44.4, -100.2], 'TN': [35.9, -86.4], 'TX': [31.5, -99.4], 'UT': [39.3, -111.7],
                                'VT': [44.0, -72.7], 'VA': [37.5, -78.8], 'WA': [47.4, -120.5], 'WV': [38.9, -80.5],
                                'WI': [44.6, -89.7], 'WY': [43.0, -107.5], 'DC': [38.9, -77.0], 'PR': [18.2, -66.4]
                            };

                            // Group alerts by state to avoid clutter
                            const alertsByState = {};
                            weatherData.features?.forEach(alert => {
                                const props = alert.properties;
                                const state = props.areaDesc?.match(/,\s*([A-Z]{2})(?:\s|$|;)/)?.[1] ||
                                              props.senderName?.match(/([A-Z]{2})$/)?.[1];
                                if (state && stateCentroids[state]) {
                                    if (!alertsByState[state] ||
                                        (props.severity === 'Extreme' && alertsByState[state].severity !== 'Extreme')) {
                                        alertsByState[state] = {
                                            state,
                                            severity: props.severity,
                                            event: props.event,
                                            headline: props.headline,
                                            description: props.description?.substring(0, 200) + '...',
                                            count: (alertsByState[state]?.count || 0) + 1
                                        };
                                    } else {
                                        alertsByState[state].count++;
                                    }
                                }
                            });

                            // Draw weather alerts as triangles
                            Object.values(alertsByState).forEach(alert => {
                                const coords = stateCentroids[alert.state];
                                if (!coords) return;
                                const [x, y] = projection([coords[1], coords[0]]);
                                const color = weatherColors[alert.severity] || '#ffaa00';

                                if (x && y) {
                                    g.append('text')
                                        .attr('x', x)
                                        .attr('y', y + 3)
                                        .attr('fill', color)
                                        .attr('font-size', '10')
                                        .attr('font-family', 'monospace')
                                        .attr('text-anchor', 'middle')
                                        .attr('class', 'weather-alert')
                                        .text('‚ñ≤');

                                    // Hit area for tooltip
                                    g.append('circle')
                                        .attr('cx', x).attr('cy', y).attr('r', 10)
                                        .attr('fill', 'transparent')
                                        .attr('class', 'hotspot-hit')
                                        .on('mouseenter', function(event) {
                                            const rect = mapPanel.getBoundingClientRect();
                                            const countText = alert.count > 1 ? ` (+${alert.count - 1} more)` : '';
                                            tooltip.innerHTML = `<strong style="color:${color}">‚ö† ${alert.event}</strong>${countText}<br>${alert.headline || alert.state}`;
                                            tooltip.style.display = 'block';
                                            tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                        })
                                        .on('mousemove', function(event) {
                                            const rect = mapPanel.getBoundingClientRect();
                                            tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                        })
                                        .on('mouseleave', function() {
                                            tooltip.style.display = 'none';
                                        });
                                }
                            });

                            console.log(`Loaded ${Object.keys(alertsByState).length} weather alert regions`);
                        } catch(weatherErr) {
                            console.log('Weather alerts unavailable:', weatherErr.message);
                        }

                        // Fetch and render global earthquakes (USGS API)
                        try {
                            const quakeData = await __fetchJson('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson');

                            // Earthquake magnitude colors
                            const getQuakeColor = (mag) => {
                                if (mag >= 7) return '#ff0000';
                                if (mag >= 6) return '#ff4400';
                                if (mag >= 5) return '#ff8800';
                                return '#ffaa00';
                            };

                            // Draw earthquakes as concentric circles
                            quakeData.features?.slice(0, 30).forEach(quake => {
                                const coords = quake.geometry.coordinates;
                                const props = quake.properties;
                                const [x, y] = projection([coords[0], coords[1]]);
                                const mag = props.mag;
                                const color = getQuakeColor(mag);
                                const radius = Math.max(3, mag - 2);

                                if (x && y) {
                                    // Outer ring
                                    g.append('circle')
                                        .attr('cx', x).attr('cy', y)
                                        .attr('r', radius + 3)
                                        .attr('fill', 'none')
                                        .attr('stroke', color)
                                        .attr('stroke-width', 1)
                                        .attr('opacity', 0.4);

                                    // Inner circle
                                    g.append('circle')
                                        .attr('cx', x).attr('cy', y)
                                        .attr('r', radius)
                                        .attr('fill', color)
                                        .attr('opacity', 0.7);

                                    // Hit area for tooltip
                                    g.append('circle')
                                        .attr('cx', x).attr('cy', y)
                                        .attr('r', 10)
                                        .attr('fill', 'transparent')
                                        .attr('class', 'hotspot-hit')
                                        .on('mouseenter', function(event) {
                                            const rect = mapPanel.getBoundingClientRect();
                                            const time = new Date(props.time).toLocaleString();
                                            const depth = coords[2].toFixed(1);
                                            tooltip.innerHTML = `<strong style="color:${color}">M${mag.toFixed(1)} Earthquake</strong><br>${props.place}<br><span style="opacity:0.7">Depth: ${depth}km ‚Ä¢ ${time}</span>`;
                                            tooltip.style.display = 'block';
                                            tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                        })
                                        .on('mousemove', function(event) {
                                            const rect = mapPanel.getBoundingClientRect();
                                            tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                            tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                        })
                                        .on('mouseleave', function() {
                                            tooltip.style.display = 'none';
                                        });
                                }
                            });

                            console.log(`Loaded ${Math.min(quakeData.features?.length || 0, 30)} earthquakes`);
                        } catch(quakeErr) {
                            console.log('Earthquake data unavailable:', quakeErr.message);
                        }

                    } catch(e) {
                        console.error('Map error:', e);
                    }

                    // ===== Flight radar (military/transport aircraft via OpenSky) =====
                    // Keep it sparse: only show likely military/transport callsigns.
                    const flightLayer = g.append('g').attr('class', 'flight-layer');
                    let flightMarkers = [];

                    // ===== OSM / Overpass layers (bases + nuclear + naval hubs) =====
                    // These are NOT live ship tracks; they are infrastructure locations from OpenStreetMap.
                    const osmLayer = g.append('g').attr('class', 'osm-layer');
                    const osmNuclearLayer = osmLayer.append('g').attr('class', 'osm-nuclear-layer');
                    const osmBaseLayer = osmLayer.append('g').attr('class', 'osm-base-layer');
                    const osmNavalLayer = osmLayer.append('g').attr('class', 'osm-naval-layer');

                    const OVERPASS_ENDPOINT = 'https://overpass-api.de/api/interpreter';
                    const overpassCache = new Map();
                    const overpassState = { inFlight: false, lastFetchMs: 0, lastKey: '' };

                    async function __fetchJsonPost(url, body, contentType = 'application/x-www-form-urlencoded; charset=utf-8') {
                        const useProxy = await __probeLocalProxy();
                        const finalUrl = useProxy ? `/proxy?url=${encodeURIComponent(url)}` : url;
                        const resp = await fetch(finalUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': contentType },
                            body,
                            cache: 'no-store'
                        });
                        if (!resp.ok) throw new Error(`Fetch failed (${resp.status})`);
                        return await resp.json();
                    }

                    function getViewportBbox() {
                        // Compute geo bbox of the current visible viewport.
                        const t = d3.zoomTransform(svg.node());
                        const p0 = t.invert([0, 0]);
                        const p1 = t.invert([width, height]);
                        const ll0 = projection.invert(p0);
                        const ll1 = projection.invert(p1);
                        if (!ll0 || !ll1) return null;

                        const lonA = ll0[0], latA = ll0[1];
                        const lonB = ll1[0], latB = ll1[1];
                        const south = Math.max(-90, Math.min(latA, latB));
                        const north = Math.min(90, Math.max(latA, latB));
                        let west = normaliseLon180(Math.min(lonA, lonB));
                        let east = normaliseLon180(Math.max(lonA, lonB));

                        // If the view crosses the dateline, fall back to full world width.
                        if (Math.abs(east - west) > 240) {
                            west = -180;
                            east = 180;
                        }

                        return { south, west, north, east };
                    }

                    function overpassKeyFor(bbox, zoomK) {
                        // Round bbox to reduce churn; include a coarse zoom bucket.
                        const z = Math.round((zoomK || 1) * 2) / 2;
                        const r = (n) => Math.round(n * 10) / 10;
                        return `${z}:${r(bbox.south)},${r(bbox.west)},${r(bbox.north)},${r(bbox.east)}`;
                    }

                    function extractCenter(el) {
                        if (!el) return null;
                        if (el.type === 'node' && typeof el.lat === 'number' && typeof el.lon === 'number') return { lat: el.lat, lon: el.lon };
                        const c = el.center;
                        if (c && typeof c.lat === 'number' && typeof c.lon === 'number') return { lat: c.lat, lon: c.lon };
                        return null;
                    }

                    function tagScaleKind(selection, kind) {
                        selection.attr('data-scale-kind', kind);
                        return selection;
                    }

                    function safeNameFromTags(tags, fallback) {
                        const t = tags || {};
                        const name = String(t.name || t['name:en'] || '').trim();
                        return name || fallback;
                    }

                    function formatTagsSummary(tags, fields) {
                        const out = [];
                        for (const f of fields) {
                            const v = tags?.[f];
                            if (v) out.push(`${f}: ${String(v)}`);
                        }
                        return out.join(' ‚Ä¢ ');
                    }

                    function drawOsmPoint(layer, lon, lat, glyph, color, tooltipHtml, baseFont = 10) {
                        const pt = projection([lon, lat]);
                        if (!pt) return;
                        const [x, y] = pt;
                        if (!x || !y) return;

                        const txt = layer.append('text')
                            .attr('x', x)
                            .attr('y', y + 3)
                            .attr('fill', color)
                            .attr('font-size', String(baseFont))
                            .attr('font-family', 'monospace')
                            .attr('text-anchor', 'middle')
                            .attr('opacity', 0.95)
                            .text(glyph);
                        tagScaleKind(txt, 'icon');
                        txt.attr('data-base-font', String(baseFont));

                        layer.append('circle')
                            .attr('cx', x).attr('cy', y)
                            .attr('r', 10)
                            .attr('fill', 'transparent')
                            .attr('class', 'hotspot-hit')
                            .on('mouseenter', function(event) {
                                const rect = mapPanel.getBoundingClientRect();
                                tooltip.innerHTML = tooltipHtml;
                                tooltip.style.display = 'block';
                                tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                            })
                            .on('mousemove', function(event) {
                                const rect = mapPanel.getBoundingClientRect();
                                tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                            })
                            .on('mouseleave', function() {
                                tooltip.style.display = 'none';
                            });
                    }

                    async function refreshOverpassLayers(force = false) {
                        const t = d3.zoomTransform(svg.node());
                        const k = t?.k || 1;

                        // Only fetch detailed infra when zoomed in enough to avoid clutter + load.
                        if (k < 2.0) {
                            osmNuclearLayer.selectAll('*').remove();
                            osmBaseLayer.selectAll('*').remove();
                            osmNavalLayer.selectAll('*').remove();
                            return;
                        }

                        const bbox = getViewportBbox();
                        if (!bbox) return;

                        const key = overpassKeyFor(bbox, k);
                        const nowMs = Date.now();
                        if (!force) {
                            if (overpassState.inFlight) return;
                            if (key === overpassState.lastKey && (nowMs - overpassState.lastFetchMs) < 20000) return;
                        }

                        if (overpassCache.has(key)) {
                            renderOverpassResult(overpassCache.get(key));
                            overpassState.lastKey = key;
                            overpassState.lastFetchMs = nowMs;
                            updateMarkerScale(k);
                            return;
                        }

                        overpassState.inFlight = true;
                        overpassState.lastKey = key;
                        overpassState.lastFetchMs = nowMs;

                        try {
                            // Keep queries narrow: only nodes/ways/relations that can be represented as points.
                            const bb = `${bbox.south},${bbox.west},${bbox.north},${bbox.east}`;
                                                        const q = `
[out:json][timeout:25];
(
  // Nuclear power plants
  node["power"="plant"]["plant:source"="nuclear"](${bb});
  way["power"="plant"]["plant:source"="nuclear"](${bb});
  relation["power"="plant"]["plant:source"="nuclear"](${bb});
  node["power"="generator"]["generator:source"="nuclear"](${bb});
  way["power"="generator"]["generator:source"="nuclear"](${bb});
  relation["power"="generator"]["generator:source"="nuclear"](${bb});

    // Military bases / facilities (broad)
    // Many places are tagged as landuse=military or military=barracks, not just military=base.
    node["military"~"^(base|naval_base|airfield|barracks)$"](${bb});
    way["military"~"^(base|naval_base|airfield|barracks)$"](${bb});
    relation["military"~"^(base|naval_base|airfield|barracks)$"](${bb});
    node["landuse"="military"](${bb});
    way["landuse"="military"](${bb});
    relation["landuse"="military"](${bb});
    // Military aerodromes are often aeroway=aerodrome + military=yes/airfield.
    node["aeroway"="aerodrome"]["military"~"^(yes|airfield)$"](${bb});
    way["aeroway"="aerodrome"]["military"~"^(yes|airfield)$"](${bb});
    relation["aeroway"="aerodrome"]["military"~"^(yes|airfield)$"](${bb});

  // Naval hubs / ports tagged as naval base (infrastructure, not live ships)
  node["harbour"="naval_base"](${bb});
  way["harbour"="naval_base"](${bb});
  relation["harbour"="naval_base"](${bb});
);
out center;
`;

                            const data = await __fetchJsonPost(OVERPASS_ENDPOINT, `data=${encodeURIComponent(q)}`);
                            overpassCache.set(key, data);
                            renderOverpassResult(data);
                            updateMarkerScale(k);
                        } catch (e) {
                            console.log('Overpass unavailable:', e?.message || e);
                        } finally {
                            overpassState.inFlight = false;
                        }
                    }

                    function renderOverpassResult(data) {
                        osmNuclearLayer.selectAll('*').remove();
                        osmBaseLayer.selectAll('*').remove();
                        osmNavalLayer.selectAll('*').remove();

                        const els = Array.isArray(data?.elements) ? data.elements : [];
                        const seen = new Set();

                        for (const el of els) {
                            const id = `${el.type}:${el.id}`;
                            if (seen.has(id)) continue;
                            seen.add(id);

                            const center = extractCenter(el);
                            if (!center) continue;

                            const tags = el.tags || {};
                            const lon = center.lon;
                            const lat = center.lat;

                            // Nuclear
                            const isNuclear = (tags.power === 'plant' && tags['plant:source'] === 'nuclear') || (tags.power === 'generator' && tags['generator:source'] === 'nuclear');
                            if (isNuclear) {
                                const name = safeNameFromTags(tags, 'Nuclear');
                                const meta = formatTagsSummary(tags, ['operator', 'plant:output:electricity', 'generator:output:electricity', 'wikidata']);
                                const html = `<strong style="color:#ffff00">‚ò¢ ${escapeHtml(name)}</strong>${meta ? `<br><span style="opacity:0.7">${escapeHtml(meta)}</span>` : ''}`;
                                drawOsmPoint(osmNuclearLayer, lon, lat, '‚ò¢', '#ffff00', html, 10);
                                continue;
                            }

                            // Military base / facility
                            const mil = String(tags.military || '').trim();
                            const landuse = String(tags.landuse || '').trim();
                            const aeroway = String(tags.aeroway || '').trim();
                            const isMil = (
                                mil === 'base' || mil === 'naval_base' || mil === 'airfield' || mil === 'barracks' ||
                                landuse === 'military' ||
                                (aeroway === 'aerodrome' && (mil === 'yes' || mil === 'airfield'))
                            );

                            if (isMil) {
                                const fallbackName = (mil === 'airfield' || (aeroway === 'aerodrome' && (mil === 'yes' || mil === 'airfield')))
                                    ? 'Military airfield'
                                    : (mil === 'naval_base' ? 'Naval base' : (mil === 'barracks' ? 'Barracks' : 'Military site'));
                                const name = safeNameFromTags(tags, fallbackName);
                                const kind = mil === 'naval_base' ? 'Naval base'
                                    : (mil === 'airfield' ? 'Airfield'
                                        : (mil === 'barracks' ? 'Barracks'
                                            : (landuse === 'military' ? 'Military area' : 'Military site')));
                                const meta = formatTagsSummary(tags, ['operator', 'owner', 'access', 'wikidata']);
                                const html = `<strong style="color:#ff00ff">‚òÖ ${escapeHtml(name)}</strong><br><span style="opacity:0.7">${escapeHtml(kind)}${meta ? ` ‚Ä¢ ${escapeHtml(meta)}` : ''}</span>`;
                                drawOsmPoint(osmBaseLayer, lon, lat, '‚òÖ', '#ff00ff', html, 10);
                                continue;
                            }

                            // Naval harbour marker
                            if (String(tags.harbour || '') === 'naval_base') {
                                const name = safeNameFromTags(tags, 'Naval hub');
                                const meta = formatTagsSummary(tags, ['operator', 'access', 'wikidata']);
                                const html = `<strong style="color:#00aaff">‚öì ${escapeHtml(name)}</strong><br><span style="opacity:0.7">Naval hub (OSM)${meta ? ` ‚Ä¢ ${escapeHtml(meta)}` : ''}</span>`;
                                drawOsmPoint(osmNavalLayer, lon, lat, '‚öì', '#00aaff', html, 11);
                                continue;
                            }
                        }
                    }

                    function looksMilitaryOrTransportCallsign(cs) {
                        const c = String(cs || '').trim().toUpperCase();
                        if (!c) return false;
                        // Common transport/military prefixes (heuristic; not authoritative)
                        return (
                            c.startsWith('RCH') || // USAF Reach
                            c.startsWith('HKY') || // USAF (varies)
                            c.startsWith('CFC') || // Canada
                            c.startsWith('RRR') || // RAF
                            c.startsWith('LAGR') ||
                            c.startsWith('CNV') ||
                            c.startsWith('SAM') || // Special Air Mission
                            c.startsWith('NATO') ||
                            c.startsWith('ASY') ||
                            c.startsWith('NOH')
                        );
                    }

                    async function refreshFlightRadar() {
                        try {
                            // Sample a handful of strategic regions (keeps API volume low).
                            const regions = [
                                { name: 'DC', lat: 38.9, lon: -77.0 },
                                { name: 'EU', lat: 50.0, lon: 10.0 },
                                { name: 'ME', lat: 29.5, lon: 47.5 },
                                { name: 'INDOPAC', lat: 22.0, lon: 120.0 }
                            ];

                            const all = [];
                            for (const r of regions) {
                                const data = await __fetchJson(`https://opensky-network.org/api/states/all?lamin=${r.lat - 6}&lomin=${r.lon - 10}&lamax=${r.lat + 6}&lomax=${r.lon + 10}`);
                                const states = Array.isArray(data?.states) ? data.states : [];
                                for (const s of states) {
                                    const icao24 = s?.[0];
                                    const callsign = (s?.[1] || '').trim();
                                    const lon = s?.[5];
                                    const lat = s?.[6];
                                    const velocity = s?.[9];
                                    const heading = s?.[10];
                                    const alt = s?.[13] ?? s?.[7];
                                    if (typeof lon !== 'number' || typeof lat !== 'number') continue;
                                    if (!looksMilitaryOrTransportCallsign(callsign)) continue;
                                    all.push({ icao24, callsign, lon, lat, velocity, heading, alt });
                                }
                            }

                            // De-dupe by icao24
                            const byId = new Map();
                            for (const f of all) {
                                if (!f.icao24) continue;
                                if (!byId.has(f.icao24)) byId.set(f.icao24, f);
                            }
                            flightMarkers = Array.from(byId.values()).slice(0, 120);

                            flightLayer.selectAll('*').remove();
                            for (const f of flightMarkers) {
                                const [x, y] = projection([f.lon, f.lat]);
                                if (!x || !y) continue;
                                const gF = flightLayer.append('g').attr('transform', `translate(${x},${y})`);

                                // Visible plane marker: glyph + small dot. (Heuristic MIL/TRANS only.)
                                const planeGlyph = gF.append('text')
                                    .attr('x', 0)
                                    .attr('y', 3)
                                    .attr('fill', '#00aaff')
                                    .attr('font-size', '12')
                                    .attr('font-family', 'monospace')
                                    .attr('text-anchor', 'middle')
                                    .attr('opacity', 0.95)
                                    .text('‚úà');
                                tagScaleKind(planeGlyph, 'icon');
                                planeGlyph.attr('data-base-font', '12');

                                gF.append('circle')
                                    .attr('r', 3.2)
                                    .attr('fill', '#00aaff')
                                    .attr('opacity', 0.45)
                                    .attr('data-base-r', '3.2');
                                gF.append('circle')
                                    .attr('r', 9)
                                    .attr('fill', 'transparent')
                                    .attr('class', 'hotspot-hit')
                                    .on('mouseenter', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        const kts = (typeof f.velocity === 'number') ? Math.round(f.velocity * 1.94384) : null;
                                        const altFt = (typeof f.alt === 'number') ? Math.round(f.alt * 3.28084) : null;
                                        const meta = [kts !== null ? `${kts} kt` : null, altFt !== null ? `${altFt.toLocaleString()} ft` : null].filter(Boolean).join(' ‚Ä¢ ');
                                        tooltip.innerHTML = `<strong style="color:#00aaff">‚úà ${escapeHtml(f.callsign || 'MIL/TRANS')}</strong><br><span style="opacity:0.7">${escapeHtml(meta || '')}</span>`;
                                        tooltip.style.display = 'block';
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mousemove', function(event) {
                                        const rect = mapPanel.getBoundingClientRect();
                                        tooltip.style.left = (event.clientX - rect.left + 15) + 'px';
                                        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
                                    })
                                    .on('mouseleave', function() {
                                        tooltip.style.display = 'none';
                                    });
                            }

                            // Apply current zoom scaling to the newly created markers.
                            const currentTransform = d3.zoomTransform(svg.node());
                            if (currentTransform) updateMarkerScale(currentTransform.k);
                        } catch (e) {
                            console.log('Flight radar unavailable:', e?.message || e);
                        }
                    }

                    // ===== Zoom with icon downscaling =====
                    function updateMarkerScale(k) {
                        const kk = Math.max(1, k || 1);

                        // We want icons to get SMALLER as we zoom in.
                        // The map group scales by kk, so we downscale markers by kk^p to make net screen size shrink.
                        // Tune so markers get smaller when zooming in, but remain visible.
                        // Screen size ~= base / kk^(power-1)
                        const ICON_POWER = 1.35;
                        const TEXT_POWER = 1.25;
                        const MIN_ICON_SCREEN_PX = 2.2;
                        const MIN_TEXT_SCREEN_PX = 7.0;

                        // Circles: treat as icons by default.
                        g.selectAll('circle[data-base-r]:not(.hotspot-hit)')
                            .attr('r', function() {
                                const base = parseFloat(this.getAttribute('data-base-r') || '0');
                                const kind = this.getAttribute('data-scale-kind') || 'icon';
                                const power = (kind === 'text') ? TEXT_POWER : ICON_POWER;
                                const desired = base / Math.pow(kk, power);
                                const minMapR = MIN_ICON_SCREEN_PX / kk;
                                return Math.max(desired, minMapR);
                            });

                        // Text: default to shrinking (treat as icon-ish text by default).
                        g.selectAll('text[data-base-font]')
                            .attr('font-size', function() {
                                const base = parseFloat(this.getAttribute('data-base-font') || '0');
                                const kind = this.getAttribute('data-scale-kind') || 'text';
                                const power = kind === 'icon' ? ICON_POWER : TEXT_POWER;
                                const desired = base / Math.pow(kk, power);
                                const minScreen = kind === 'icon' ? MIN_ICON_SCREEN_PX : MIN_TEXT_SCREEN_PX;
                                const minMap = minScreen / kk;
                                return Math.max(desired, minMap).toFixed(3);
                            });
                    }

                    // Capture base sizes so we can adjust them on zoom.
                    // Default all text to shrinking ('text') unless explicitly set to 'icon'.
                    g.selectAll('text').each(function() {
                        const fs = this.getAttribute('font-size');
                        if (fs) this.setAttribute('data-base-font', fs);
                        if (!this.getAttribute('data-scale-kind')) this.setAttribute('data-scale-kind', 'text');
                    });
                    g.selectAll('circle').each(function() {
                        if (this.classList && this.classList.contains('hotspot-hit')) return;
                        const r = this.getAttribute('r');
                        if (r) this.setAttribute('data-base-r', r);
                        if (!this.getAttribute('data-scale-kind')) this.setAttribute('data-scale-kind', 'icon');
                    });

                    const zoom = d3.zoom()
                        .scaleExtent([1, 8])
                        .on('zoom', (event) => {
                            g.attr('transform', event.transform);
                            updateMarkerScale(event.transform.k);
                        });
                    svg.call(zoom);

                    // Refresh OSM layers on zoom end (debounced).
                    let osmRefreshT = 0;
                    function scheduleOsmRefresh() {
                        clearTimeout(osmRefreshT);
                        osmRefreshT = setTimeout(() => refreshOverpassLayers(false), 350);
                    }
                    zoom.on('end.osm', () => scheduleOsmRefresh());

                    // Initial OSM fetch (if starting zoom is already in range)
                    refreshOverpassLayers(true);

                    // Start flight radar refresh loop (sparse; every ~3 minutes)
                    refreshFlightRadar();
                    setInterval(refreshFlightRadar, 180000);
                })();
            </script>
        </section>

        <!-- Political / World News -->
        <section class="panel" data-panel="politics">
            <div class="panel-header">
                <span class="panel-title">World / Geopolitical</span>
                <span class="panel-count" id="politicsCount">-</span>
            </div>
            <div class="panel-content" id="politicsPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Technology News -->
        <section class="panel" data-panel="tech">
            <div class="panel-header">
                <span class="panel-title">Technology / AI</span>
                <span class="panel-count" id="techCount">-</span>
            </div>
            <div class="panel-content" id="techPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Financial News -->
        <section class="panel" data-panel="finance">
            <div class="panel-header">
                <span class="panel-title">Financial</span>
                <span class="panel-count" id="financeCount">-</span>
            </div>
            <div class="panel-content" id="financePanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Pentagon Tracker -->
        <section class="panel" data-panel="pentagon">
            <div class="panel-header">
                <span class="panel-title">Pentagon Tracker</span>
                <div class="panel-header-right">
                    <details class="panel-config" id="pentagonConfig">
                        <summary class="panel-config-summary">Config</summary>
                        <div class="panel-config-body" onclick="event.stopPropagation()">
                            <div class="panel-config-section">
                                <div class="panel-config-label">BestTime private API key</div>
                                <input class="settings-input panel-config-input" id="besttimeApiKeyPrivateInput" type="password" placeholder="api_key_private" autocomplete="off" spellcheck="false" />
                                <button class="panel-config-btn" onclick="saveBestTimePrivateKey()">Save key</button>
                                <div class="settings-hint">Stored in localStorage (client-side). Don‚Äôt use a sensitive key on a public host.</div>
                            </div>
                            <div class="panel-config-section">
                                <div class="panel-config-label">Locations</div>
                                <div class="panel-config-grid">
                                    <input class="settings-input panel-config-input" id="pentagonLocName" type="text" placeholder="Name" autocomplete="off" spellcheck="false" />
                                    <input class="settings-input panel-config-input" id="pentagonLocLat" type="number" step="0.000001" placeholder="Lat" />
                                    <input class="settings-input panel-config-input" id="pentagonLocLng" type="number" step="0.000001" placeholder="Lng" />
                                    <input class="settings-input panel-config-input" id="pentagonLocRadius" type="number" step="50" placeholder="Radius (m)" />
                                </div>
                                <button class="panel-config-btn" onclick="addPentagonLocationFromInputs()">Add location</button>
                                <div class="panel-config-list" id="pentagonLocationsList"></div>
                            </div>
                        </div>
                    </details>
                    <span class="panel-count" id="pentagonCount">-</span>
                </div>
            </div>
            <div class="panel-content" id="pentagonPanel">
                <div class="loading-msg">Open Config to set BestTime key and locations</div>
            </div>
        </section>

        <!-- Government / Policy -->
        <section class="panel" data-panel="gov">
            <div class="panel-header">
                <span class="panel-title">Government / Policy</span>
                <span class="panel-count" id="govCount">-</span>
            </div>
            <div class="panel-content" id="govPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Sector Heatmap -->
        <section class="panel" data-panel="heatmap">
            <div class="panel-header">
                <span class="panel-title">Sector Heatmap</span>
            </div>
            <div class="panel-content" id="heatmapPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Markets -->
        <section class="panel wide" data-panel="markets">
            <div class="panel-header">
                <span class="panel-title">Markets</span>
                <span class="panel-count" id="marketsCount">-</span>
            </div>
            <div class="panel-content" id="marketsPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Commodities -->
        <section class="panel" data-panel="commodities">
            <div class="panel-header">
                <span class="panel-title">Commodities / VIX</span>
            </div>
            <div class="panel-content" id="commoditiesPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Polymarket -->
        <section class="panel wide" data-panel="polymarket">
            <div class="panel-header">
                <span class="panel-title">Polymarket Predictions</span>
                <span class="panel-count" id="polymarketCount">-</span>
            </div>
            <div class="panel-content" id="polymarketPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Whale Wallet Watch -->
        <section class="panel" data-panel="whales">
            <div class="panel-header">
                <span class="panel-title">Whale Watch</span>
                <span class="panel-count" id="whaleCount">-</span>
            </div>
            <div class="panel-content" id="whalePanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Main Character -->
        <section class="panel" data-panel="mainchar">
            <div class="panel-header">
                <span class="panel-title">Main Character</span>
                <span class="panel-count">Today</span>
            </div>
            <div class="panel-content" id="mainCharPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Money Printer -->
        <section class="panel" data-panel="printer">
            <div class="panel-header">
                <span class="panel-title">Money Printer</span>
                <span class="panel-count">Fed Balance Sheet</span>
            </div>
            <div class="panel-content" id="printerPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Government Contracts -->
        <section class="panel wide" data-panel="contracts">
            <div class="panel-header">
                <span class="panel-title">Gov Contracts</span>
                <span class="panel-count" id="contractsCount">-</span>
            </div>
            <div class="panel-content" id="contractsPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- AI Arms Race -->
        <section class="panel wide" data-panel="ai">
            <div class="panel-header">
                <span class="panel-title">AI Arms Race</span>
                <span class="panel-count" id="aiCount">-</span>
            </div>
            <div class="panel-content" id="aiPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Layoffs Tracker -->
        <section class="panel" data-panel="layoffs">
            <div class="panel-header">
                <span class="panel-title">Layoffs Tracker</span>
                <span class="panel-count" id="layoffsCount">-</span>
            </div>
            <div class="panel-content" id="layoffsPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Venezuela Situation -->
        <section class="panel" data-panel="venezuela">
            <div class="panel-header">
                <span class="panel-title">Venezuela Situation</span>
                <span class="panel-count" id="venezuelaStatus">-</span>
            </div>
            <div class="panel-content" id="venezuelaPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Greenland Situation -->
        <section class="panel" data-panel="greenland">
            <div class="panel-header">
                <span class="panel-title">Greenland Situation</span>
                <span class="panel-count" id="greenlandStatus">-</span>
            </div>
            <div class="panel-content" id="greenlandPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- Intel Feed -->
        <section class="panel wide" data-panel="intel">
            <div class="panel-header">
                <span class="panel-title">Intel Feed</span>
                <span class="panel-count" id="intelCount">-</span>
            </div>
            <div class="panel-content" id="intelPanel">
                <div class="loading-msg">Loading...</div>
            </div>
        </section>

        <!-- My Monitors -->
        <section class="panel" data-panel="monitors">
            <div class="panel-header">
                <span class="panel-title">My Monitors</span>
                <span class="panel-count" id="monitorsCount">-</span>
            </div>
            <div class="panel-content" id="monitorsPanel">
                <div class="monitors-empty">
                    No monitors configured
                    <div class="monitors-empty-hint">Click Settings ‚Üí Add Monitor to get started</div>
                </div>
            </div>
        </section>

    </main>

    <!-- Core utilities -->
    <script src="js/core/storage.js"></script>
    <script src="js/core/utils.js"></script>
    <script src="js/core/proxy.js"></script>

    <!-- Constants and configuration -->
    <script src="js/constants.js"></script>

    <!-- Services -->
    <script src="js/services/feeds.js"></script>
    <script src="js/services/yahoo.js"></script>

    <!-- Map modules -->
    <script src="js/map/data-loaders.js"></script>
    <script src="js/map/popups.js"></script>
    <script src="js/map/zoom.js"></script>
    <script src="js/map/globe.js"></script>

    <!-- Panel modules -->
    <script src="js/panels/panel-manager.js"></script>
    <script src="js/panels/news.js"></script>
    <script src="js/panels/markets.js"></script>
    <script src="js/panels/monitors.js"></script>
    <script src="js/panels/polymarket.js"></script>
    <script src="js/panels/congress.js"></script>
    <script src="js/panels/whales.js"></script>
    <script src="js/panels/misc.js"></script>
    <script src="js/panels/livestream.js"></script>
    <script src="js/panels/pentagon.js"></script>

    <!-- Main application -->
    <script src="js/app.js"></script>
</body>
</html>
